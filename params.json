{"name":"Process-oriented Programming","tagline":"Process-oriented Programming","body":"### Introduction\r\nSince the nineties when Object Oriented Programming (OOP) is introduced to solve software development issues, we keep using the same concepts over and over. In the same time, our needs are in a changing mode that is influenced by the changed in several factors like computing infrastructure, and human resources. Nowadays, cloud computing is taking its way to dominate the IT infrastructure, and the concept of remote employee is spreading all over industries. Thus, enhancing the concepts of OOP and add others to keep up with the changes around us is mandatory. Therefore, Process Oriented Programming (POP) is a different way to develop software that has capabilities to keep up with the changes that we experience.\r\n\r\n### The Specifications of Process Oriented Programming (POP)\r\nIn order to develop a POP software there are two fundamental components: engine and application. An engine should be off-the-shelf product that is developed in purpose to maintain certain type of application. For example, if you are planning to develop a web application that is cloud-aware you may need to consider an engine that is designed for cloud infrastructure. An engine works as a smart virtual environment for your POP system. Thus, each engine should provide the minimum capabilities as the following:\r\n\r\n* Interpret and execute processes: that means an engine is in charge to coordinate and execute an application's processes, stages and tasks.\r\n* Maintain the data and data-flow. An engine will deliver the required data to a task inside a process in order to make the task able to perform its job. It also takes what the task produce and pass it to the next task.\r\n* Provide the required resources of software libraries.\r\n* Provide a communication environment between processes and tasks.\r\n\r\n\r\nIn the other hand, the application is what need to be developed in order to carry out an entity’s business. each application contains four essential components as the following:\r\n\r\n* Processes, where the processes of the application are defined. each process composed of stages, and each stage is composed of atom tasks.\r\n* Data, where the data that are required by the application are defined. Each data model contains inputs that are used by the tasks.\r\n* Tasks, where the atom tasks are defined and implemented. Each task is composed of imperative computation statements. For example, assign X to Y (Y=X).\r\n* Controls, where the process controls such as conditions are defineds. Controls similar to tasks except that expected product of a condition is True or False.\r\n\r\nAn application will be engine-dependent so POP application needs to be built based on the engine specifications, unless that we come with a standard to smooth the movement from an engine to another.\r\n\r\n### Application Processes\r\n\r\nProcesses are vital in POP paradigm. In fact, they are the main place that we need to start with and break the system down to small atom tasks. In the end of the day each software we create will do certain steps to produce what we are looking for. For example, a calculator application will do the following in order to calculate this expression: 1+2.\r\n\r\n    step#1: Receive the the expression as an input.\r\n\r\n    step#2: interpret and validate the input.\r\n\r\n    step#3: use the system computer resources to loop over the expression and calculate it.\r\n\r\n    step#4: format the output.\r\n\r\nthese steps will be the result in the end of the day if we created the calculator application in Object Oriented Programing (OOP) or in POP. From those steps we’ll create the process and break it down into stages and tasks.\r\nProcess Stages\r\n\r\nThe goal of dividing each process into stages is to group the transactional tasks are able to be executed sequentially with no need for input data. In other word, each stage composited of tasks that can be executed without waiting for any input or an event to append in the future. For example, a university course management system that has a process called: Course Registration Process. If the business logic for course registration required approval from the course instructor, then the process will be divided into two stages. First stage will contains the following tasks:\r\n\r\n* Receive course information\r\n* Validate input\r\n* Check availability and eligibility\r\n* Send notification to the course’ instructor.\r\n\r\nThe second stage of the registration process will contains the following tasks:\r\n* Receive approval details\r\n* Register the course\r\n* Notify the student.\r\n\r\n### Application Data\r\nDuring the execution of each process, tasks may need data in order to proceed in the execution. The points where the data can be received are the start of each stage. Thus, the first task in each stage might be a receiving task that receives data from a human interface or an API and then continue in the execution of the process.\r\n\r\nEach stage data model contains several inputs that are described and specified. For example, in the course registration process, we need at least two data forms: Course Information, and Instructor Approval. Course Information Model might has the following inputs:\r\n\r\n* Student-ID: Integer (6 digits)\r\n* Course Name: String (100 A-Z chars)\r\n* Section Number: Integer (3 digits)\r\n* Quarter Name: String (50 A-Z chars)\r\n\r\n### Application Tasks\r\nA task is an atom component in POP paradigm. It contains the implementation of the actual action that need to be performed. Each task is composited of imperative computational statements. In fact, each task is a small function that receives two parameters: IN and OUT, and return True, or False. The return value is an indication for the engine about the status of the task execution whether it succeeded or failed. The IN parameter is a data structure that contains all the required data that is needed by the task. In the same time, the OUT parameter is a data structure that contains all the data that is produced by the tasks. For example, the “Format The Output” task in the calculater application might be as the following:\r\n```\r\nFunction format_output(in, &out){\r\n\r\nresult= in[“result”];\r\n\r\nif(result == null) {\r\n\r\nout[“error_message”]=”result is null”;\r\n\r\nreturn false;\r\n\r\n}\r\n\r\nout[“formated_result”]=”The result is: ”+result;\r\n\r\nreturn true;\r\n\r\n}\r\n```\r\n### Application Controls\r\nApplication controls are similar application tasks except that there is no OUT parameter. The purpose of the controls is to examine the data inside the IN parameter and return True or False. For example, the process of course registration we need a control to decide whether to register a course for the student or not based on the instructor approval. Thus, we need to have a control called: check instructor approval as the following.\r\n```\r\nFunction check_instructure_approval(in){\r\n\r\napproval= in[“instructur_approval”];\r\n\r\nif(approval == true) return true;\r\n\r\nelse return false;\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}